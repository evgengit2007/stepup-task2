# stepup-task2
Задание направлено на отработку навыка разработки инструментальных решений на основе рефлексии, позволяющих расширять функциональность существующего кода. К решению необходимо приложить модульные тесты.

Разработайте обобщенный утилитный метод cache. Метод принимает объект и возвращает такую версию данного объекта, у которого вызовы всех методов, помеченных аннотацией @Cache, кэшируются. При вызове кэшируемого метода необходимо проанализировать состояние объекта:

·       Если метод вызывается впервые после создания кэшируемого объекта - то он вызывается обычным образом.

·       Если метод вызывается повторно и с момента прошлого вызова внесены изменения в состояние объекта – то он вызывается обычным образом.

·       Если метод вызывается повторно и объект не был изменен с момента прошлого вызова – то вместо вызова метода необходимо вернуть то же значение, что возвращал метод при предыдущем вызове.

Для определения того, был ли изменено состояние объекта способом, влияющим на сброс кэширования, используйте аннотацию @Mutator. Данная аннотация вешается на методы, которые изменяют состояние объекта значимым образом.

Обратите внимание, что метод принимает объект обобщенного типа T и возвращает объект того же типа.

С целью упрощения кода, в данном задании можно считать, что кэшировать достаточно только такие методы, которые объект данного класса реализовал от какого-либо интерфейса.

Разберем задачу на примере. Допустим мы имеем интерфейс Fractionable определяющий метод получения вещественного значения у объекта.

https://davtb-teachbase.api.eric.s3storage.ru/material_images/9f947bc6292b84231435de32b9588715e588c7f9.png
Реализуется данный интерфейс классом Fraction, являющимся абстракцией для дробного значения и состоящий из числителя и знаменателя. У данного класса метод doubleValue помечен аннотацией @Cache, и, следовательно, должен кэшироваться. Оба сеттера помечены аннотацией @Mutator, и, следовательно их вызов приводит к сбрасыванию кэшей.

https://davtb-teachbase.api.eric.s3storage.ru/material_images/6189dbcdd31ddabc9ac58e103595667a28d2908c.png
Далее проведем создание кэшируемой версии объекта класса Fraction и протестируем целевой метод.

https://davtb-teachbase.api.eric.s3storage.ru/material_images/e4f2e1b1d8414c2f9318a9d4252ebe909386371d.png
Сначала создаем объект и задаем ему значение, затем, на его основе, создаем кэшируемую версию.

Первый вызов метода проходит нормально, так как еще ничего не было кэшировано.

Второй и третий вызов не приводят к выводу текста на экран, так как реальный метод расчёта не был вызван, вместо него срабатывает только возвращение кэша.

Далее мы вызываем метод мутатор, что приводит к сбросу кэшей

Четвертый вызов считается новым, и пятый вызов снова будет кэшированным.

Аннотация @Cache, имеет следующие характеристики:

·       Целью может быть МЕТОД

·       Доступна во время исполнения программы

Аннотация @Mutator, имеет следующие характеристики:

·       Целью может быть МЕТОД

·       Доступна во время исполнения программы
